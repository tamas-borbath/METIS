########################################################
# Copyright (c) 2015-2017 by European Commission.      #
# All Rights Reserved.                                 #
########################################################

"""
 This script is part of the process to generate demand values for the 4 types of reserve.
 External reserve demand values can alternatively be imported in each asset of type Reserve demand.

 To generate values, first set the sizing options in the following model objects :
    - Reserve sizing (annual or hourly)
	- National reserve symmetry requirement (up down)
	- Europe regional cooperation
 Then run the following context actions in this order :
    - Imbalances generation
	- Outages generation (optional)
	- Reserve sizing
 Reserve demand time series will be computed for each zone and the corresponding assets will be modified.
 
 This script uses files generated by the imbalances generation script.
 When prompted, the user can also choose to use additional files generated by the outages generation script.
 Outages will then be taken into account in the sizing.
 
 If there are missing files, the list of countries and test cases for which it will be impossible to generate a sizing is returned in the command window.
 When prompted, the user can decide to compute the sizing for the rest.
 
 The reserve sizing methodology is described in appendix 7 of the Power system module documentation on the METIS web page.

"""

from com.artelys.CrystalEditor.scripting import Crystal
from com.artelys.platform.gui.dialogs import CrystalOptionDialog
from com.artelys.platform.config import Constantes
from datetime import datetime, timedelta
import csv
import imp
import os

def onExecute(action, event):
	context = action.getDestinationContext()
	if context != action.getSourceContext():
		Crystal.showErrorDialog("Cannot execute script: source and destination contexts are different!")
		return
	
	#  The user is asked if reserve sizing must be launched.
	#  This is done to make sure he or she did not click the wrong context action.
	ret = CrystalOptionDialog.showConfirmDialog(None, "Do you want to launch reserve sizing?", "Reserve sizing calculation?", CrystalOptionDialog.YES_NO_OPTION)
	if ret != 0: return

	#  The user is aksed if reserve sizing must be launched without or with outage.
	#  Before the system simulation has been performed, it is impossible to have outages.
	#  So before the simulation, the sizing should be done without outages.
	#  After, it should be done with outages.
	
	#  The answer is stored in boolean_outages
	boolean_outages = CrystalOptionDialog.showConfirmDialog(None, "Have you already computed outages, and if it is the case, do you want to take them into account for the reserve sizing?", "With outages?", CrystalOptionDialog.YES_NO_OPTION)
	CrystalOptionDialog.showConfirmDialog(None, "Reserve sizing is being launched, see log for details", "", CrystalOptionDialog.CLOSED_OPTION)

	Crystal.logInfo('')
	Crystal.logInfo('')
	if boolean_outages != 0:
		Crystal.logInfo("Launching reserve sizing without outages")
	else:
		Crystal.logInfo("Launching reserve sizing with outages")

	###########################################  ACCESS TO PARAMETERS AND CHECK THAT ALL THE FILES EXIST  ###########################################
	#  First the parameters are accessed.
	#  parameters.py contains all the parameters (name of assets, csv files, etc.) useful for the calculations.
	if os.path.isfile(Constantes.REP_CONF_XML + 'CrystalModule/internal/parameters.py'):
		script = imp.load_source("parameters", Constantes.REP_CONF_XML + 'CrystalModule/internal/parameters.py')
	else:
		Crystal.showErrorDialog('Missing file. Process is aborted.')
		Crystal.logInfo('Missing file parameters.py in ' + str(Constantes.REP_CONF_XML + '/CrystalModule/internal'))
	parameters = script.readParameters(context)
	if len(parameters) == 0:
		Crystal.showErrorDialog("Process is aborted.")
		return
	
	#  list climatic year gives the number of historical climatic years used for the calculation.
	#  It should contain 10 years.
	list_climatic_year = parameters['list_climatic_year']
	
	# testCases is a list containing the list of testCases of the context.
	testCases = context.getTestCases()

	#  a script is called that checks that all the files neeeded for the calculation exist.
	#  First it is checked that this file does exist.
	if os.path.isfile(parameters['path_to_check_file_existence']):
		check = imp.load_source(parameters['file_name_check_file_existence'], parameters['path_to_check_file_existence'])
	else:
		Crystal.logInfo('Please check that the file ' + parameters['path_to_check_file_existence'] +  ' exists.')
		Crystal.logInfo('Process is aborted.')
		Crystal.showErrorDialog('Missing file. Process is aborted')
	
	#  Then it is checked that all the scripts needed for the calculation exist. If there is a missing script, the process is aborted.
	should_process_be_aborted = check.check_if_scripts_exist(parameters)
	if should_process_be_aborted == True:
		return

	#  Then it will be checked that all the data (imbalance files and 24h wind forecast) exist.
	#  But for that, the user inputs (i.e. what the user put in the model objects) need to be accessed.
	
	#  So the user inputs in the model object files are read.
	functions = imp.load_source(parameters['file_name_functions_for_reserve_sizing'], parameters['path_to_functions_for_reserve_sizing'])
	userInput = functions.getUserInput(context, parameters)
	
	#  in case of missing model objects or data, the process is stopped and the user is warned.
	if userInput['aborted'] == True:
		Crystal.showErrorDialog('There is a problem with the model objects. See log for details. Process is aborted.')
		return

	#  annualSizing is a boolean: fixed or hourly sizing.
	#  boolean_cooperation is a boolean: cooperation or no cooperation allowed.
	#  dict_regions is a dict containing the list of regions to be used in case of cooperation, and the countries belonging to each region.
	#  boolean_symmetrical_reserve is a boolean: should the reserve symetry requirement be activated or not.
	#  dict_joint_reserve_boolean is a dict containing, for each country, a 0 or a 1 depending on whether synchronized sizing should be symmetrical or not.
	#  boolean_aggregation: is there aggregation or not.
	#  list_countries: list of counntries for which the calculation is going to be performed.
	#  list_countries_in_context: list of counntries in the context.
	#  dict_aggregation: in case of aggregation, a dict containing the name of the areas being aggregated and the countries aggregated together.
	#  For instance: {'Iberia': ['ES', 'PT']}
	#  mean_demand : mean_demand per testCase and per country, scaled in case of aggregation.
	#  dict_PV_fleet: installed PV capacity per country, scaled in case of aggregation.
	#  dict_wind_off_fleet: installed wind offshore capacity, scaled in case of aggregation.
	#  dict_wind_on_fleet: installed wind onshore capacity, scaled in case of aggregation.
	#  climatic_year_per_TC: climatic year used to create each testCase.
	annualSizing = userInput['annualSizing']
	boolean_cooperation = userInput['boolean_cooperation']
	dict_regions =  userInput['dict_regions'] 
	boolean_symmetrical_reserve = userInput['boolean_symmetrical_reserve'] 
	dict_joint_reserve_boolean = userInput['dict_joint_reserve_boolean'] 
	boolean_aggregation = userInput['boolean_aggregation'] 
	list_countries = userInput['list_countries'] 
	list_countries_in_context = userInput['list_countries_in_context'] 
	dict_aggregation = userInput['dict_aggregation'] 
	mean_demand = userInput['mean_demand'] 
	dict_PV_fleet = userInput['dict_PV_fleet']
	dict_wind_off_fleet= userInput['dict_wind_off_fleet']
	dict_wind_on_fleet = userInput['dict_wind_on_fleet']
	climatic_year_per_TC = userInput['climatic_year_per_TC']
	list_additional_countries = userInput['list_additional_countries']

	#  now that user input is available, it can be checked that the files needed for the calculation exist.
	#  dict_countries_no_imbalances contains, for each testCase, a list of countries for which Imbalances files are missing.
	dict_countries_no_imbalances = check.check_if_files_for_reserve_sizing_exist(list_countries, parameters, boolean_outages, annualSizing, dict_wind_off_fleet, dict_wind_on_fleet, testCases)
	#  it is tested, for each testCase, whether there is at least one country with a missing file.
	#  If that is the case, the user is asked to check the log for the detail of the countries, and whether the calculation should be performed anyways.
	for testCase in testCases:
		if len(dict_countries_no_imbalances[testCase]) != 0:
			ret = CrystalOptionDialog.showConfirmDialog(None, testCase + ": Some imbalances files are missing for some countries (see log for details). Do you want to launch reserve sizing anyways?", "Missing imbalances files", CrystalOptionDialog.YES_NO_OPTION)
			if ret != 0: 
				return

	#  FCR sizing is accessed and will be added to the aFRR sizing in order to get the synchronized sizing.
	#  FCR sizing is given as an input and stored in a csv file. Values are in MW.
	FCR_sizing = functions.readFCR(list_countries, parameters, list_additional_countries)
	if FCR_sizing['aborted'] == True:
		Crystal.showErrorDialog('Problem with the FCR sizing file. Process is aborted.')
		return

	######################################   WARNING ABOUT DATA USED FOR IMBALANCES  ###################################### 
	#  Imbalance components that are used for the imbalance generation process were created based on a certain set of data.
	#  So the user has to be warned that potentially the imbalances that were created do not match exactly the data it is using.
	Crystal.showErrorDialog('Imbalances generation in METIS is based upon PRIMES EUCO27 scenario data. The imbalances that were generated were resized according to data from the current scenario, but inconsistency may have appeared if load or availability profiles are significantly different.')

	###########################################   BEGINNING OF THE CALCULATION  ########################################### 

	#depending on the choices done by the user (hourly sizing or fixed sizing, cooperation or no cooperation),
	#different scripts are executed.

	#   First case: annual sizing, no cooperation
	#######################################################################################################################
	if annualSizing == 1:
		if boolean_cooperation == False:
			Crystal.logInfo('Beginning of the annual reserve calculation')
			Crystal.logInfo('Fixed annual aFRR sizing is going to be calculated')
			#  the script containing the reserve calculation in the fixed case is accessed.
			file_with_script = imp.load_source(parameters['file_name_for_fixed_reserve_sizing'], parameters['path_to_file_for_fixed_reserve_sizing'])
			results = file_with_script.calculation(list_countries, dict_countries_no_imbalances, list_climatic_year, boolean_outages, context, testCases, boolean_symmetrical_reserve, dict_joint_reserve_boolean, climatic_year_per_TC)
			
			#  aFRR_down, aFRR_up, etc are dicts containing, for each testCase and for each country, the sizing in MW.
			aFRR_down = results['aFRR_down']
			aFRR_up = results['aFRR_up']
			mFRR_down = results['mFRR_down']
			mFRR_up = results['mFRR_up']

			#  aFRR and FCR are added together in order to get the synchronized reserve sizing.
			sync_reserve_down = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, aFRR_down, FCR_sizing, testCases, list_additional_countries)
			sync_reserve_up = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, aFRR_up, FCR_sizing, testCases, list_additional_countries)
		
			#  mFRR sizing are summed over the aggregation area in case of aggregation.
			#  If there is no aggregation, the result sumOfmFRR is equal to mFRR.
			sumOfmFRR_up = functions.sumOfmFRR(dict_aggregation, mFRR_up, testCases)
			sumOfmFRR_down = functions.sumOfmFRR(dict_aggregation, mFRR_down, testCases)
		
			#  finally the sizing is stored in the correct asset in METIS(synchronized up and down, mFRR up and down).
			#  In the fixed case, the same value is defined for each hour.
			#  As there is no cooperation, only the parameter 'Total reserve' is used.
			
			#  First synchronized.
			#  parameters['synchronized_down_asset_name'] returns the name of the synchronized_down asset name.
			#  parameters['total_reserve_name_in_asset'] returns the name of the Total requirement parameter name in the reserve asset.
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sync_reserve_down, parameters['synchronized_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sync_reserve_up, parameters['synchronized_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			
			#  Then mFRR.
			#  parameters['mFRR_up_asset_name'] returns the name of the mFRR_down asset name.
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_up, parameters['mFRR_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_down, parameters['mFRR_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			
			Crystal.logInfo('End of the annual reserve calculation')
			Crystal.logInfo('')
			CrystalOptionDialog.showConfirmDialog(None, "End of reserve sizing", "", CrystalOptionDialog.CLOSED_OPTION)

		#  if sizing is defined as fixed in the model object, and with cooperation, as it is an option that is not possible to be studied,
		#  the script returns a message saying it is impossible to process and another option should be chosen.
		else:
			Crystal.showErrorDialog('No fixed sizing calculation with cooperation is possible')
			Crystal.showErrorDialog('Please choose another option')
	#######################################################################################################################

	#   Second case: hourly sizing, no cooperation
	#######################################################################################################################
	else:
		if boolean_cooperation == False:
			Crystal.logInfo('Beginning of the hourly reserve calculation')
		
			#  the script containing the reserve calculation in the hourly case with no cooperation is accessed.
			# results = imp.load_source(parameters['file_name_for_hourly_reserve_sizing'], parameters['path_to_file_for_hourly_reserve_sizing'])
			file_with_script = imp.load_source(parameters['file_name_for_hourly_reserve_sizing'], parameters['path_to_file_for_hourly_reserve_sizing'])
			results = file_with_script.calculation(list_countries, dict_countries_no_imbalances, list_climatic_year, boolean_outages, context, testCases, parameters, boolean_symmetrical_reserve, dict_joint_reserve_boolean, climatic_year_per_TC, dict_wind_on_fleet, dict_wind_off_fleet, mean_demand, boolean_aggregation, dict_aggregation)
													
			#  hourly aFRR_donw and up are dicts containing, for each testCase, 8760 values corresponding to the hourly aFRR sizing for each hour of the year.
			#  mFRR_up and down are not hourly so only one value is returned for each testCase.
			#  mean_aFRR_up and down are, for each testCase, the mean value of aFRR sizing over the year.
			hourly_aFRR_down = results['hourly_aFRR_down']
			hourly_aFRR_up = results['hourly_aFRR_up']
			mFRR_down = results['mFRR_down']
			mFRR_up = results['mFRR_up']
			
			#  aFRR and FCR are added together in order to get the synchronized reserve sizing.
			sync_reserve_down = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, hourly_aFRR_down, FCR_sizing, testCases, list_additional_countries)
			sync_reserve_up = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, hourly_aFRR_up, FCR_sizing, testCases, list_additional_countries)

			#  mFRR sizing are summed over the aggregation area in case of aggregation.
			#  If there is no aggregation, the result sumOfmFRR is equal to mFRR.
			sumOfmFRR_up = functions.sumOfmFRR(dict_aggregation, mFRR_up, testCases)
			sumOfmFRR_down = functions.sumOfmFRR(dict_aggregation, mFRR_down, testCases)

			#  finally the sizing is stored in the correct asset in METIS(synchronized up and down, mFRR up and down).
			#  In the hourly case, a different value is defined for each hour.
			#  As there is no cooperation, only the parameter 'Total reserve' is used.
			
			#  First synchronized reserve.
			#  parameters['synchronized_down_asset_name'] returns the name of the synchronized_down asset name.
			#  parameters['total_reserve_name_in_asset'] returns the name of the Total requirement parameter name in the reserve asset.
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sync_reserve_down, parameters['synchronized_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sync_reserve_up, parameters['synchronized_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)

			#  Then mFRR reserve.
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_up, parameters['mFRR_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_down, parameters['mFRR_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)

			Crystal.logInfo('End of the hourly reserve calculation')
			CrystalOptionDialog.showConfirmDialog(None, "End of reserve sizing", "", CrystalOptionDialog.CLOSED_OPTION)

	#######################################################################################################################

	#   Third case: hourly sizing with cooperation
	#######################################################################################################################
		else:
			Crystal.logInfo('Beginning of the hourly reserve calculation with cooperation')
			Crystal.logInfo('Hourly aFRR sizing with cooperation is going to be calculated')
			Crystal.logInfo('It will be set to the "National procurement minimum" parameter of the reserve asset')

			#  HOURLY SIZING WITH COOPERATION
			#  the script containing the reserve calculation in the hourly case with cooperation is accessed.
			file_with_script = imp.load_source(parameters['file_name_for_hourly_reserve_sizing_with_coop'], parameters['path_to_file_for_hourly_reserve_sizing_with_coop'])
			# results = imp.load_source(parameters['file_name_for_hourly_reserve_sizing_with_coop'], parameters['path_to_file_for_hourly_reserve_sizing_with_coop'])
			results = file_with_script.calculation(list_countries, dict_countries_no_imbalances, list_climatic_year, boolean_outages, context, testCases, parameters, boolean_symmetrical_reserve, dict_joint_reserve_boolean, climatic_year_per_TC, dict_wind_on_fleet, dict_wind_off_fleet, mean_demand, boolean_aggregation, dict_aggregation, dict_regions)
										
			#  national procurement min_down and up are the hourly aFRR down and up sizing in the case with cooperation.
			#  8760 values per country and per testCase.
			national_procurement_min_down = results['hourly_aFRR_down']
			national_procurement_min_up = results['hourly_aFRR_up']
	
			#  mFRR_value_national_min_up and down are the mFRR values in case of cooperation, one value per testCase.
			#  It needs to be saved because it will be set to the 'National procurement minimum' value
			mFRR_value_national_min_up = results['mFRR_up_with_coop']
			mFRR_value_national_min_down = results['mFRR_down_with_coop']

			Crystal.logInfo('Hourly aFRR sizing with cooperation has been calculated')

			#  HOURLY SIZING WITHOUT COOPERATION
			#  Once the hourly aFRR sizing with cooperation has been calculated, the hourly sizing with no cooperation needs to be calculated too.
			Crystal.logInfo('Hourly aFRR sizing with no cooperation is going to be calculated')
			Crystal.logInfo('It will be set to the "Total requirement" parameter of the reserve asset')

			#  the file used in the hourly sizing case with no cooperation is thus called.
			file_with_script = imp.load_source(parameters['file_name_for_hourly_reserve_sizing'], parameters['path_to_file_for_hourly_reserve_sizing'])
			results = file_with_script.calculation(list_countries, dict_countries_no_imbalances, list_climatic_year, boolean_outages, context, testCases, parameters, boolean_symmetrical_reserve, dict_joint_reserve_boolean, climatic_year_per_TC, dict_wind_on_fleet, dict_wind_off_fleet, mean_demand, boolean_aggregation, dict_aggregation)

			#  total_requirement_up and down contain the hourly sizing in the case with no cooperation.
			#  8760 values per country and per testCase.
			total_requirement_down = results['hourly_aFRR_down']
			total_requirement_up = results['hourly_aFRR_up']

			#  mFRR_total_down and up contain the values of mFRR in the case with no cooperation.
			#  One value per country and per testCase.
			mFRR_total_down = results['mFRR_down']
			mFRR_total_up = results['mFRR_up']
			
			#  it is made sure that mFRR_total value is always larger than mFRR_value_national
			for testCase in testCases:
				for country in list_countries:
					mFRR_total_down[testCase][country] = max(mFRR_total_down[testCase][country], mFRR_value_national_min_down[testCase][country])
					mFRR_total_up[testCase][country] = max(mFRR_total_up[testCase][country], mFRR_value_national_min_up[testCase][country])
			
			#  mFRR sizing are summed over the aggregation area in case of aggregation.
			#  If there is no aggregation, the result sumOfmFRR is equal to mFRR.
			sumOfmFRR_up_national = functions.sumOfmFRR(dict_aggregation, mFRR_value_national_min_up, testCases)
			sumOfmFRR_down_national = functions.sumOfmFRR(dict_aggregation, mFRR_value_national_min_down, testCases)
			
			#  mFRR sizing are summed over the aggregation area in case of aggregation.
			#  If there is no aggregation, the result sumOfmFRR is equal to mFRR.
			sumOfmFRR_total_up = functions.sumOfmFRR(dict_aggregation, mFRR_total_up, testCases)
			sumOfmFRR_total_down = functions.sumOfmFRR(dict_aggregation, mFRR_total_down, testCases)
			
			Crystal.logInfo('Hourly aFRR sizing with no cooperation has been calculated')

			# it is possible that for a few hours of the year and for certain countries, the National procurement minimum
			# is greater than the Total requirement.
			# As it is normally impossible, a script is run that sets the Total requirement value as the max of the two values.
			
			# the script returns total_up_corrected and total_down_corrected, which are two dictionaries containing
			# the correct values for the total reserve requirement in each country, i.e. making sure that Total requirement is higher than the National procurement minimum
			total_up_corrected = functions.getMax(total_requirement_up, national_procurement_min_up, list_countries, testCases)
			total_down_corrected = functions.getMax(total_requirement_down, national_procurement_min_down, list_countries, testCases)

			#  aFRR and FCR are added together in order to get the synchronized reserve sizing.
			national_sync_reserve_down = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, national_procurement_min_down, FCR_sizing, testCases, list_additional_countries)
			national_sync_reserve_up = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, national_procurement_min_up, FCR_sizing, testCases, list_additional_countries)

			total_sync_reserve_down = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, total_down_corrected, FCR_sizing, testCases, list_additional_countries)
			total_sync_reserve_up = functions.addFCRtoGetSyncReserveSizing(dict_aggregation, total_up_corrected, FCR_sizing, testCases, list_additional_countries)

			#  finally the sizing is stored in the correct asset in METIS(synchronized up and down, mFRR up and down).
			#  In the hourly case, a different value is defined for each hour.
			
			#  First synchronized.
			#  As there is cooperation, first the parameter 'Total reserve' is used.
			if boolean_aggregation == False:
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, total_sync_reserve_down, parameters['synchronized_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, total_sync_reserve_up, parameters['synchronized_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
			else:
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, national_sync_reserve_down, parameters['synchronized_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, national_sync_reserve_up, parameters['synchronized_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				
			#  Then the 'Local reserve' parameter is used.
			#  parameters['min_local_reserve_name_in_asset'] returns the name of the National min reserve procurement parameter in the reserve asset.
			functions.setLocalReserveValueToAsset(context, list_countries_in_context, total_sync_reserve_down, national_sync_reserve_down, parameters['synchronized_down_asset_name'], parameters['min_local_reserve_name_in_asset'], testCases, dict_aggregation, parameters)
			functions.setLocalReserveValueToAsset(context, list_countries_in_context, total_sync_reserve_up, national_sync_reserve_up, parameters['synchronized_up_asset_name'], parameters['min_local_reserve_name_in_asset'], testCases, dict_aggregation, parameters)

			#  Then mFRR reserve.
			#  first the parameter 'Total reserve' is used.
			if boolean_aggregation == False:
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_total_down, parameters['mFRR_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_total_up, parameters['mFRR_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)	
			else:
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_down_national, parameters['mFRR_down_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				functions.setTotalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_up_national, parameters['mFRR_up_asset_name'], parameters['total_reserve_name_in_asset'], testCases, parameters)
				
			#  Then the 'Local reserve' parameter is used.
			functions.setLocalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_total_down, sumOfmFRR_down_national, parameters['mFRR_down_asset_name'], parameters['min_local_reserve_name_in_asset'], testCases, dict_aggregation, parameters)
			functions.setLocalReserveValueToAsset(context, list_countries_in_context, sumOfmFRR_total_up, sumOfmFRR_up_national, parameters['mFRR_up_asset_name'], parameters['min_local_reserve_name_in_asset'], testCases, dict_aggregation, parameters)
			
			#  Then RESERVE behavior is set to True for transmissions within a cooperation zone
			functions.setReserveBehaviorsForTransmissions(context, dict_regions)

			Crystal.logInfo('End of the hourly reserve calculation with cooperation')
			CrystalOptionDialog.showConfirmDialog(None, "End of reserve sizing", "", CrystalOptionDialog.CLOSED_OPTION)
	#####################################################################
	
