########################################################
# Copyright (c) 2015-2017 by European Commission.      #
# All Rights Reserved.                                 #
########################################################

"""
  This script is part of the process to generate demand values for the 4 types of reserve.
 External reserve demand values can alternatively be imported in each asset of type Reserve demand.

 To generate values, first set the sizing options in the following model objects :
    - Reserve sizing (annual or hourly)
	- National reserve symmetry requirement (up down)
	- Europe regional cooperation
 Then run the following context actions in this order :
    - Imbalances generation
	- Outages generation (optional)
	- Reserve sizing
 
 This script generates outages for each asset possibly having outages (CCGT, coal, lignite and nuclear).
 It then uses files generated by the imbalances generation script and combines imbalances with outages to update imbalances. 
 
 If there are missing files, the list of countries and test cases for which it will be impossible to update imbalances is returned in the command window.
 When prompted, the user can decide to update the imbalances for the rest.
 This script writes the generated imbalances in the data directory so that they can be read by the reserve sizing script.
 
 The reserve sizing methodology is described in appendix 7 of the Power system module documentation on the METIS web page.
 The outages generation methodology is described in section 3.4 of the Power market module documentation on the METIS web page.

"""


from com.artelys.CrystalEditor.scripting import Crystal
from com.artelys.platform.gui.dialogs import CrystalOptionDialog
from com.artelys.platform.config import Constantes
import imp
import os

def onExecute(action, event):

	context = action.getDestinationContext()
	if context != action.getSourceContext():
		Crystal.showErrorDialog("Cannot execute script: source and destination contexts are different!")
		return
	
	ret = CrystalOptionDialog.showConfirmDialog(None, "Do you want to launch outages calculation?", "Outages calculation?", CrystalOptionDialog.YES_NO_OPTION)
	if ret != 0: return

	###########################################  ACCESS TO PARAMETERS AND CHECK THAT ALL THE FILES EXIST  ###########################################
	#  First the parameters are accessed.
	#  parameters.py contains all the parameters (name of assets, csv files, etc.) useful for the calculations.
	if os.path.isfile(Constantes.REP_CONF_XML + 'CrystalModule/internal/parameters.py'):
		script = imp.load_source("parameters", Constantes.REP_CONF_XML + 'CrystalModule/internal/parameters.py')
	else:
		Crystal.showErrorDialog('Missing file. Process is aborted.')
		Crystal.logInfo('Missing file parameters.py in ' + str(Constantes.REP_CONF_XML + '/CrystalModule/internal'))
	parameters = script.readParameters(context)
	if len(parameters) == 0:
		Crystal.showErrorDialog("Process is aborted.")
		return
	#  list climatic year gives the number of historical climatic years used for the calculation.
	#  It should contain 10 years.
	list_climatic_year = parameters['list_climatic_year']
	
	# testCases is a list containing the list of testCases of the context.
	testCases = context.getTestCases()
	

	#  a script is called that checks that all the files neeeded for the calculation exist.
	#  First it is checked that this file does exist.
	if os.path.isfile(parameters['path_to_check_file_existence']):
		check = imp.load_source(parameters['file_name_check_file_existence'], parameters['path_to_check_file_existence'])
	else:
		Crystal.logInfo('Please check that the file ' + parameters['path_to_check_file_existence'] +  ' exists.')
		Crystal.logInfo('Process is aborted.')
		Crystal.showErrorDialog('Missing file. Process is aborted')
	
	#  Then it is checked that all the scripts needed for the calculation exist. If there is a missing script, the process is aborted.
	should_process_be_aborted = check.check_if_scripts_exist_for_outages(parameters)
	if should_process_be_aborted == True:
		return
	
	#  User inputs are accessed.
	functions = imp.load_source(parameters['file_name_functions_for_reserve_sizing'], parameters['path_to_functions_for_reserve_sizing'])
	userInput = functions.getUserInput(context, parameters)

	#  boolean_aggregation : is there aggregation or not.
	#  dict_installed_capa_from_model_object: installed capacity per technology potentially having outages.
	#  As decribed in the first comments of this script, it is used to split the outages in between countries in case of aggregation.
	#  list_countries: countries for which outages will be calculated (individual countries, as opposed to aggregated countries in case of aggregation)
	#  list_countries_in_context: countries in the context, different from list_countries in case of aggregation.
	#  dict_aggregation: in case of aggregation, a dict containing the name of the areas being aggregated and the countries aggregated together.
	#  For instance: {'Iberia': ['ES', 'PT']}
	#  If there is no aggregation, it is just the list of countries: {'ES': ['ES'], 'PT': ['PT']}
	boolean_aggregation = userInput['boolean_aggregation']  
	dict_installed_capa_from_model_object = userInput['dict_installed_capa_from_model_object']	
	list_countries = userInput['list_countries'] 
	list_countries_in_context = userInput['list_countries_in_context'] 
	dict_aggregation = userInput['dict_aggregation'] 
	
	#  it is checked that the installed capacities, which are needed for the scaling of outages, exist.
	#  First it is checked that all the countries are defined. 
	for country in list_countries:
		if country not in dict_installed_capa_from_model_object:
			Crystal.showErrorDialog('Missing values in model object. See log for details.')
			Crystal.logInfo('No values of installed capacity for thermal assets in ' + country)
			Crystal.logInfo('Process is aborted.')
			return
		#  then it is checked that all the technologies are defined.
		for techno in [parameters['coal_parameter_name'], parameters['lignite_parameter_name'], parameters['CCGT_parameter_name'], parameters['nuclear_parameter_name']]:
			if techno not in dict_installed_capa_from_model_object[country]:
				Crystal.showErrorDialog('Missing values in model object. See log for details.')
				Crystal.logInfo('Missing value of installed capacity for ' + techno + ' in ' + country)
				Crystal.logInfo('Process is aborted.')
				return

	#  the installed capacity per technology is calculated for each area in case of aggregation.
	for area in dict_aggregation:
		#  if len(dict_aggregation[area]) > 1 it means the area is an aggregated one. Otherwise it is an individual country.
		if len(dict_aggregation[area]) > 1:
			dict_installed_capa_from_model_object[area] = {}
			for country in dict_aggregation[area]:
				for techno in dict_installed_capa_from_model_object[country]:
					if techno not in dict_installed_capa_from_model_object[area]:
						dict_installed_capa_from_model_object[area][techno] = 0
			for country in dict_aggregation[area]:
				for techno in dict_installed_capa_from_model_object[country]:
					dict_installed_capa_from_model_object[area][techno] = dict_installed_capa_from_model_object[area][techno] + dict_installed_capa_from_model_object[country][techno]


				
	###########################################   BEGINNING OF THE CALCULATION  ########################################### 				
	#  the script needed for the outages calculation is called.
	script_outages = imp.load_source(parameters['file_name_script_for_outages'], parameters['path_to_script_for_outages'])

	#  the script used to write the imbalances plus outages is called.
	functions_outages = imp.load_source(parameters['file_name_functions_for_outages'], parameters['path_to_functions_for_outages'])
	
	############################
	list_countries_no_calc = []
	boolean_results = {}
	for area in list_countries_in_context:
		for testCase in testCases:
			#  for each testCase, outages are calculated and 5min values for the country are stored in outages_5_min.
			#  boolean_results checks whether there are results for the testCase or not.
			#  If there are no results, the process is continued for the next testCase.
			[dict_5_min_outages, boolean_results] = script_outages.outages_calculation(context, area, testCase, testCases, parameters, boolean_results)
			if boolean_results[testCase] == 0:
				continue
			else:
				#  Outages per technology are added in order to get the total outages.
				#  Outages are scaled for the case where there is aggregation.
				#  if the area that is being calculated is not an aggregated one, there is no need for a scaling.
				#  if the area is an aggregated one, outages are scaled for each country inside the area before they are added to the imbalances.
				for country in dict_aggregation[area]:
					list_5_min_scaled_outages = functions.scaleOutages(dict_5_min_outages, dict_installed_capa_from_model_object, country, area)
					#  then imbalances that were calculated previously and stored in a csv file are accessed.
					path = parameters['path_to_imbalances_csv']
					file_name = parameters['imbalances_csv_name']
					#  If there is no imbalances files for a given country, it is added to list_countries_no_calc
					[imbalances, list_countries_no_calc] = functions_outages.read_csv(path, file_name, country, testCase, list_climatic_year, list_countries_no_calc)
					#  finally the sum of imbalances and outages is stored in a csv file.
					path = parameters['path_to_imbalances_with_outages_csv']
					file_name = parameters['imbalances_with_outages_csv_name']
					if country not in list_countries_no_calc:
						functions_outages.write_csv_outages(country, list_5_min_scaled_outages, imbalances, list_climatic_year, testCase, path, file_name)
					else:
						Crystal.logInfo('Sum of outages and imbalances could not be calculated for ' + country + ' because there was no imbalances file')

	#  If there are missing results for a given testCase, it is displayed in the interface.
	for testCase in testCases:
		if boolean_results[testCase] == 0:
			Crystal.logInfo('Since there are no computational results for ' + testCase + ', the process was not performed for this testCase')
			Crystal.showErrorDialog('Since there are no computational results for ' + testCase + ', the process was not performed for this testCase')

	Crystal.logInfo('End of outages calculations')
	CrystalOptionDialog.showConfirmDialog(None, 'End of outages calculations', "", CrystalOptionDialog.CLOSED_OPTION)
	

